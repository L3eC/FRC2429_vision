// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2429.Spartan2018.autonomous;import org.usfirst.frc2429.Spartan2018.Robot;

import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveRobotPID extends Command {
	private PIDController pid;
	private double heading;
	private double minimumSpeed = 0.15;
	private int executionCount;
	private double distance;
	boolean bUseImaging = false;

	// Provide a simple one that takes the global defaults for speed limit and tolerance
	public DriveRobotPID(double distance) {
		this(distance, Robot.drivetrain.speedLimit, 6.0);
		bUseImaging = false;
	}

	// Provide a simple one that gets its parameters from the camera
	public DriveRobotPID(boolean bUseImaging) {
		this(Robot.imageProcessor.getCubecamDistance(), Robot.drivetrain.speedLimit, 10.0);
		bUseImaging = true;
	}
	
	//  Make  a version where we can set the max speed and tolerance - keep us from knocking the robot over   
	
	public DriveRobotPID(double distance, double maxSpeed, double tolerance) {
    	
    	requires(Robot.drivetrain);
		pid = new PIDController(Robot.drivetrain.kPdriveWheel, Robot.drivetrain.kIdriveWheel, Robot.drivetrain.kDdriveWheel, new PIDSource() {
			PIDSourceType m_sourceType = PIDSourceType.kDisplacement;

			@Override
			public double pidGet() {
				//return Robot.drivetrain.getDistanceToObstacle();
				return Robot.drivetrain.driveEncoder.getDistance();
			}

			@Override
			public void setPIDSourceType(PIDSourceType pidSource) {
				m_sourceType = pidSource;
			}

			@Override
			public PIDSourceType getPIDSourceType() {
				return m_sourceType;
			}
		}, new PIDOutput() {
			@Override
			public void pidWrite(double d) {
				double twist = Robot.drivetrain.kPdriveGyro*(heading - Robot.drivetrain.driveGyro.getAngle());
				//Try to keep the belts from getting too much jerk - use the acceleration limit
				//Robot.drivetrain.smoothDrive(  d + (minimumSpeed * Math.signum(d)), twist);
				Robot.drivetrain.drive(  d + (minimumSpeed * Math.signum(d)), twist);
		    	executionCount++;
		    	SmartDashboard.putNumber("Iterations", executionCount);
		    	SmartDashboard.putNumber("Error", pid.getError());
		    	//SmartDashboard.putNumber("mvstrtPID out", d);
				//SmartDashboard.putNumber("twPID out",  - d + minimumSpeed * Math.signum(-d));
			}
		});
		
		pid.setOutputRange(-maxSpeed, maxSpeed);
		pid.setAbsoluteTolerance(tolerance);
		
		//Turn this on to get it to work right
		this.distance = distance;
		pid.setSetpoint(distance);

    	
    }
    

@Deprecated
public DriveRobotPID(double distance, boolean bUseImaging) {
	
	requires(Robot.drivetrain);
	pid = new PIDController(Robot.drivetrain.kPdriveWheel, Robot.drivetrain.kIdriveWheel, Robot.drivetrain.kDdriveWheel, new PIDSource() {
		PIDSourceType m_sourceType = PIDSourceType.kDisplacement;

		@Override
		public double pidGet() {
			//return Robot.drivetrain.getDistanceToObstacle();
			return Robot.drivetrain.driveEncoder.getDistance();
		}

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			m_sourceType = pidSource;
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return m_sourceType;
		}
	}, new PIDOutput() {
		@Override
		public void pidWrite(double d) {
			double twist = Robot.drivetrain.kPdriveGyro*(heading - Robot.drivetrain.driveGyro.getAngle());
			//Try to keep the belts from getting too much jerk - use the acceleration limit
			//Robot.drivetrain.smoothDrive(  d + (minimumSpeed * Math.signum(d)), twist);
			Robot.drivetrain.drive(  d + (minimumSpeed * Math.signum(d)), twist);
	    	executionCount++;
	    	SmartDashboard.putNumber("Iterations", executionCount);
	    	SmartDashboard.putNumber("Error", pid.getError());
	    	//SmartDashboard.putNumber("mvstrtPID out", d);
			//SmartDashboard.putNumber("twPID out",  - d + minimumSpeed * Math.signum(-d));
		}
	});
	pid.setOutputRange(-Robot.drivetrain.speedLimit, Robot.drivetrain.speedLimit);
	pid.setAbsoluteTolerance(6.0);

	// Use that boolean to see if we will use the distance passed in or the autonomous values ... may want to make this a switch
	//I'm sure there is a cleaner way to do this
	
	//Turn this on to get it to work right
	//this.distance = distance;
	//pid.setSetpoint(distance);
	
	// Use that boolean to see if we will use the distance passed in or the
	// autonomous values ... may want to make this a switch
	// I'm sure there is a cleaner way to do this
	if (bUseImaging) {
		this.distance=Robot.imageProcessor.getCubecamDistance();
		pid.setSetpoint(this.distance - 5);
	} else {
		this.distance = distance;
		pid.setSetpoint(distance);
	}
	
}


    // Called just before this Command runs the first time
    protected void initialize() {
		// Get everything in a safe starting state.
    	System.out.println("DriveRobotPID called for: " + String.format("%.2f",distance) + " inches at "  + String.format("%.2f", Timer.getFPGATimestamp()- Robot.enabledTime)  + "s");
    	Robot.drivetrain.reset();
    	heading=Robot.drivetrain.driveGyro.getAngle();
    	
		//I'm doing this twice in debugging to see if it will work for sure
    	//Have to reset these guys here if you are calling it from the dashboard - needs to update the goals
    			if (bUseImaging) {
    				this.distance=Robot.imageProcessor.getCubecamAngle();
    				pid.setSetpoint(this.distance);
    			}			else {
    				pid.setSetpoint(this.distance);
    				
    			}
		
    	//pid.setPID(Robot.drivetrain.kPWheel, Robot.drivetrain.kIWheel, Robot.drivetrain.kDWheel);
    	pid.reset();
		pid.enable();
    	executionCount = 0;
    	SmartDashboard.putString("Current Command", this.getClass().getSimpleName());
    	SmartDashboard.putNumber("Parameter", this.distance);
    }


    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
    	// either we made it as far as we needed to or the arm hit something
		return Robot.liftMechanism.isArmContact() || pid.onTarget();
    }

    // Called once after isFinished returns true
    protected void end() {
    	// Stop PID and the wheels
    	System.out.println("DriveRobotPID ended at: " + String.format("%.2f", Timer.getFPGATimestamp()- Robot.enabledTime) + "s");
    	pid.disable();
    	Robot.drivetrain.drive(0, 0);
    	
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	// Stop PID and the wheels
    	System.out.println("DriveRobotPID interrupted at: " + String.format("%.2f", Timer.getFPGATimestamp()- Robot.enabledTime) + "s");
    	pid.disable();
    	Robot.drivetrain.drive(0, 0);
    }
}
