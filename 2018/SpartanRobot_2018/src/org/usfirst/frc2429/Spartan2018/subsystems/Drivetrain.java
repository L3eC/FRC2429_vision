// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2429.Spartan2018.subsystems;
import org.usfirst.frc2429.Spartan2018.OI;
import org.usfirst.frc2429.Spartan2018.Robot;
import org.usfirst.frc2429.Spartan2018.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *  Driving subsystem
 */
public class Drivetrain extends Subsystem {
	
//------------------------------------------------------------------------------------

    private final SpeedController frontLeftTalon =  new Talon(0);
    private final SpeedController rearLeftTalon =  new Talon(1);
    private final SpeedControllerGroup leftSpeedControllerGroup = new SpeedControllerGroup(frontLeftTalon, rearLeftTalon);
    private final SpeedController frontRightTalon =  new Talon(2);
    private final SpeedController rearRightTalon =  new Talon(3);
    private final SpeedControllerGroup rightSpeedControllerGroup = new SpeedControllerGroup(frontRightTalon, rearRightTalon);
    private final DifferentialDrive robotDrive = new DifferentialDrive(leftSpeedControllerGroup, rightSpeedControllerGroup);
    
    public final ADXRS450_Gyro driveGyro = new ADXRS450_Gyro();
    public final Encoder driveEncoder =  new Encoder(0,1,false, Encoder.EncodingType.k4X);
    private final Ultrasonic driveSonicLeft = new Ultrasonic(6, 7);
    private final Ultrasonic driveSonicRight = new Ultrasonic(4, 5);
    
	// Used to make robot accelerate smoother - try to avoid tipping from sudden starts
	private static double currentThrust = 0, currentTwist = 0;
	private static double accelerationLimit = 0.12;
    //Don't forget to update this for competition
    public double speedLimit = 0.8;
    public boolean joyStickEnabled = true;
    public double autonomousTwistSpeed=0.95;
    int updateCounter = 0;
    
	// Have some global constants that determine how the PIDs react on the wheel encoder
	public static double kPdriveWheel = 0.035;
	public static double kIdriveWheel = 0.005;
	public static double kDdriveWheel = 0.5;
	// Used to determine the proportional constant for correcting heading during  movement
	public static double kPdriveGyro = 0.03;    //Corrects twist in all movement commands, 0.012 is default
	public static double kDdriveGyro = 0.3;   // 0 is default
	// Have some global constants that determine how the PIDs react on the gyro
	public static double kPtwistGyro = 0.2;
	public static double kItwistGyro = 0.0;
	public static double kDtwistGyro = 0.2;

	
  //------------------------------------------------------------------------------------

    
    //Constructor added 1/27/2018 CJH modeled after the GearsBot template - getting rid of RobotMap redundancy      
    public Drivetrain() {
		super();

		//Set parameters for the drivetrain
	    //driveEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
	  	//encoder set
	    driveEncoder.setMaxPeriod(0.2);
	    driveEncoder.setMinRate(10);
	    double distancePerPulse = 2048;
	    driveEncoder.setDistancePerPulse((3.92*3.14)/distancePerPulse);
	    //COMPETITION BOT HAS THE ENCODERS ON THE RIGHT SIDE (viewed from back)
	    //THIS MEANS YOU HAVE TO REVERSE DIRECTION
	    driveEncoder.setReverseDirection(true);
	    driveEncoder.setSamplesToAverage(7);
	    driveEncoder.reset();
	    
	    
	    //robotDrive.setExpiration(0.1);
	    //robotDrive.setSafetyEnabled(true);
	    robotDrive.setMaxOutput(speedLimit);
	    robotDrive.setDeadband(0.02);
	    
		
		// Let's name the sensors on the LiveWindow - so this here instead of RobotMap
	    if (Robot.bDebugging) {
			addChild("Drive", robotDrive);
			addChild("Left Encoder", driveEncoder);
			addChild("Right Encoder", driveEncoder);
			addChild("Rangefinder Left", driveSonicLeft);
			addChild("Rangefinder Right", driveSonicRight);
			addChild("Gyro", driveGyro);
			addChild("westCoastDifferentialDrive",robotDrive);
			addChild("rightSpeedControllerGroup",rightSpeedControllerGroup);
			addChild("leftSpeedControllerGroup",leftSpeedControllerGroup);
	    }
	}
  //------------------------------------------------------------------------------------

    @Override
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
		//setDefaultCommand(new SmoothTankDrive());
		setDefaultCommand(new GyroCorrectedTankDrive());
    }
    
    //Default simple driver
    public void driveWithStick(Joystick joy) { 	
    	drive(-joy.getRawAxis(Robot.oi.YAXIS), joy.getRawAxis(Robot.oi.TWISTAXIS));
	}
    
    
    /**
	 * Need to keep from tipping over!
	 * We want to limit how fast the robot starts up, so we only change by at most
	 * accelerationLimit each update. It's also a good place to put in a dead
	 * zone, currently 0.02 because the logitech is pretty good
	 */

    public void smoothDrive(double thrust, double twist) {
		//Xbox joysticks are notoriously bad at keeping themselves calibrated to better than 0.1.  
		double deadzone = 0.02;
		if (Math.abs(thrust) < deadzone)
			currentThrust = 0;
		else {
			if (Math.abs(thrust - currentThrust) < accelerationLimit)
				currentThrust = thrust;
			else
				currentThrust = (thrust - currentThrust > 0) ? currentThrust + accelerationLimit : currentThrust - accelerationLimit;
		}

		if (Math.abs(twist) < deadzone)
			currentTwist = 0;
		else {
			if (Math.abs(twist - currentTwist) < accelerationLimit)
				currentTwist = twist;
			else
				currentTwist = (twist - currentTwist > 0) ? currentTwist + accelerationLimit
						: currentTwist - accelerationLimit;
		}

		//currentThrust = Math.signum(currentThrust)*Math.min(Math.abs(thrustLimit),Math.abs(currentThrust));
		robotDrive.arcadeDrive(currentThrust, currentTwist, true);
	}
    
	public void smoothDriveWithStick(Joystick joy) {
		//Xbox joysticks are notoriously bad at keeping themselves calibrated to better than 0.1.  
		double deadzone = 0.02;
		double thrust = -joy.getRawAxis(OI.YAXIS);
		double twist = joy.getRawAxis(OI.TWISTAXIS);
		
		if (Math.abs(thrust) < deadzone)
			currentThrust = 0;
		else {
			if (Math.abs(thrust - currentThrust) < accelerationLimit)
				currentThrust = thrust;
			else
				currentThrust = (thrust - currentThrust > 0) ? currentThrust + accelerationLimit : currentThrust - accelerationLimit;
		}

		if (Math.abs(twist) < deadzone)
			currentTwist = 0;
		else {
			if (Math.abs(twist - currentTwist) < accelerationLimit)
				currentTwist = twist;
			else
				currentTwist = (twist - currentTwist > 0) ? currentTwist + accelerationLimit
						: currentTwist - accelerationLimit;
		}

		robotDrive.arcadeDrive(currentThrust, currentTwist, true);
	}
    
    
    public void drive(double forward, double twist) { 	
    	robotDrive.arcadeDrive(forward, twist, false);
    }

    public void stop() { 	
    	drive(0,0);
	}
    
	/**
	 * Get the robot's heading.
	 *
	 * @return The robots heading in degrees.
	 */
	public double getHeading() {
		return driveGyro.getAngle();
	}

	/**
	 * Reset the robots sensors to the zero states.
	 */
	public void reset() {
		driveGyro.reset();
		driveEncoder.reset();
	}
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
	public void log() {
		updateCounter++;
		if (updateCounter%10 == 0) {
		SmartDashboard.putNumber("Drive Distance", ((int)(100*driveEncoder.getDistance()))/100.0);
		SmartDashboard.putNumber("Drive Speed", driveEncoder.getRate());
		SmartDashboard.putNumber("Gyro", ((int)(1000*driveGyro.getAngle()))/1000.0);
		}
	}
    public double getTimeout() {
    	return robotDrive.getExpiration();
    }
    public void setJoystickEnabled(boolean enable) {
    	joyStickEnabled=enable;
    }
    public boolean getJoystickEnabled() {
		return joyStickEnabled;
    }

}

