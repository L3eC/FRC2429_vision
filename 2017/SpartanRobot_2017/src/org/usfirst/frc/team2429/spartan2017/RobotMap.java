// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc.team2429.spartan2017;

import org.opencv.core.Mat;
import edu.wpi.cscore.CvSink;
import edu.wpi.cscore.VideoCamera;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.Encoder;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.Victor;
import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // drivetrain controllers
    public static SpeedController drivetrainrearLeftChannel;
    public static SpeedController drivetrainfrontLeftChannel;
    public static SpeedController drivetrainrearRightChannel;
    public static SpeedController drivetrainfrontRightChannel;
    public static RobotDrive drivetrainRobot;
    
    //ballhandling, imported from branch project ServoTest 1/25/2017
    public static CANTalon ballShooterMotor;
    //public static Talon ballShooterMotor;
    public static Victor ballGateMotor;
    public static Victor ballCollectorMotor;
    public static Victor ballAgitatorMotor;
    //climber motors
    public static Talon climberMotorL;
    public static Talon climberMotorR;
    
    //Gyro
    public static ADXRS450_Gyro gyro;
    public static double[] gyroArray;
    public static double[] gyroRateArray;
    public static double gyroAverage;
    public static double gyroRateAverage;
    public static int gyroCounter;
    
    //Encoder on mechanum well
    public static Encoder wheelEncoder;
    
    //Ultrasonic sensor
    public static AnalogInput gearUltra;
    
    //Shared resources for the camera
    public static Mat mat;
    public static CvSink cvSink;
    public static VideoCamera gearCam;
    public static VideoCamera driverCam;
    public static int gearCamHeight;
    public static int gearCamWidth;
    public static double gearCamFov;
    public static boolean offBoardVision;
    //Camera brightness and exposure for image processing 
    public static int gearCameraBrightness;
    public static int gearCameraExposure;
    public static double distancePerPulse;
    
    // Network issues
    //static NetworkTable table;
	  
    public static void init() {

        //drivetrain options
	    drivetrainrearRightChannel = new Talon(0);
	    drivetrainfrontRightChannel = new Talon(1);
	    drivetrainfrontLeftChannel = new Talon(2);
	    drivetrainrearLeftChannel = new Talon(3);
	    drivetrainRobot = new RobotDrive(drivetrainfrontLeftChannel, drivetrainrearLeftChannel,
              drivetrainfrontRightChannel, drivetrainrearRightChannel);
        
        drivetrainRobot.setSafetyEnabled(true);
        drivetrainRobot.setExpiration(0.1);
        drivetrainRobot.setSensitivity(0.5);
        drivetrainRobot.setMaxOutput(1.0);
        drivetrainRobot.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        drivetrainRobot.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
    	
        //ballhandling variables are now all completely in the subsystems
        ballShooterMotor = new CANTalon(0);  //Actually, we don't need the PWM here
        ballShooterMotor.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Absolute);
        ballShooterMotor.changeControlMode(TalonControlMode.Speed);
        //TODO: check to see the encoder and sensor are in the same direction and no reversal is needed
        ballGateMotor = new Victor(5);
        ballCollectorMotor = new Victor(6);
        //Not used at the moment - may change as of 01/25/2017 CJH
    	ballAgitatorMotor = new Victor(7);
    	climberMotorL = new Talon(8);
    	climberMotorR = new Talon(9);
        

    	//encoder set
    	wheelEncoder = new Encoder(2,3,false, Encoder.EncodingType.k4X);
    	wheelEncoder.setMaxPeriod(0.2);
    	wheelEncoder.setMinRate(10);
    	distancePerPulse= 2048;
    	wheelEncoder.setDistancePerPulse((8.0*3.14)/distancePerPulse);
    	wheelEncoder.setReverseDirection(false);
    	wheelEncoder.setSamplesToAverage(7);
    	wheelEncoder.reset();
    	
    	//gyro array for averaging
    	gyroArray = new double[10];
		gyroRateArray = new double[10];
		gyroCounter = 0;
		gyroAverage = 0.0;
        gyro =  new ADXRS450_Gyro();

        //Ultrasonic if we choose to use it
        gearUltra = new AnalogInput(0);
    	


        // throwing in a few starting lines of code to start the USB camera stream for the driver cam ONLY
     	//Needs to be cleaner - as in turning off imaging if no cameras.  hard to find that stuff.
        // put true here if you have no USB camera.  
        //still need to figure out how to fix other issues in ImageCaptureAndProcess()
        driverCam = CameraServer.getInstance().startAutomaticCapture(0);
        driverCam.setFPS(15);
        driverCam.setResolution(320, 240);
        //driverCam.setResolution(160, 120);
         offBoardVision = true;
         if (offBoardVision){
         	//gearCam = new HttpCamera("Pi GearCam", "http://raspberrypi/1186");
         	//gearCam = null;
         }
         else {
         	gearCam = CameraServer.getInstance().startAutomaticCapture(0);
         	gearCam.setFPS(10);
     		gearCamWidth = 320;
     		gearCamHeight = 240;
     		gearCameraBrightness =20;
     		gearCameraExposure = 20;
     		gearCam.setResolution(gearCamWidth, gearCamHeight);
     		gearCam.setBrightness(gearCameraBrightness);
     		gearCam.setExposureManual(gearCameraBrightness);
     		cvSink = CameraServer.getInstance().getVideo(); 	
         }
         
 		gearCamFov = 55.0;   // MS Lifecam 3000 is quoted at 59.7, seems a bit wide; maybe the 320x240 knocks it down
        mat = new Mat();
 
        
    	//live window views
       
        LiveWindow.addActuator("Drivetrain", "rearLeftChannel", (Talon) drivetrainrearLeftChannel);
        LiveWindow.addActuator("Drivetrain", "frontLeftChannel", (Talon) drivetrainfrontLeftChannel);
        LiveWindow.addActuator("Drivetrain", "rearRightChannel", (Talon) drivetrainrearRightChannel);
        LiveWindow.addActuator("Drivetrain", "frontRightChannel", (Talon) drivetrainfrontRightChannel);
        //LiveWindow.addActuator("BallHandling", "frontRightChannel", (Talon) drivetrainfrontRightChannel);
        
    }
    

    
}
