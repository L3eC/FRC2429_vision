// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team2429.spartan2017.subsystems;

import org.usfirst.frc.team2429.spartan2017.RobotMap;
import org.usfirst.frc.team2429.spartan2017.movement.MecanumDrive;

import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;

import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Drivetrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final SpeedController rearLeftChannel = RobotMap.drivetrainrearLeftChannel;
	private final SpeedController frontLeftChannel = RobotMap.drivetrainfrontLeftChannel;
	private final SpeedController rearRightChannel = RobotMap.drivetrainrearRightChannel;
	private final SpeedController frontRightChannel = RobotMap.drivetrainfrontRightChannel;
	private final RobotDrive robotDrive = RobotMap.drivetrainRobot;

	// Used to make mecanum accelerate smoother
	private static double currentX = 0, currentY = 0, currentTwist = 0;
	private static double mecanumSensitivity = 0.05;

	// Used to determine our slow motion and autonomous speed limits
	public static double dpadForwardSpeed = 0.35;
	public static double dpadStrafeSpeed = 0.5;
	public static double buttonTwistSpeed = 0.25;
	public static double autonomousGearDeliverySpeed = 0.5;  // 3/26/2017 increased from 0.4; used in RobotDriveToGearTarget

	public static double autonomousForwardSpeed = 0.5;  // 3/26/2017 increased from 0.35; used in MoveFwd and CenterGear 
	public static double autonomousStrafeSpeed = 0.5;   // never used
	public static double autonomousTwistSpeed = 0.5;  // used in twisting the robot in autonomous
	
	// Used to determine the proportional constant for correcting heading during  movement
	public static double kGyroProportional = 0.03;    //Corrects twist in all movement commands, 0.012 is default
	public static double kGyroDerivative = 0.3;   // 0 is default
	
	public static double kForwardProportional = 0.012;
	
	//These two are used in the gear delivery routine, different from the rest of the time.  
	// 0.02 and 0.25 are decent, 0.03 and 0.45 start to stutter 
	public static double kGearDeliveryForwardProportional = 0.03;
	public static double kGearDeliveryForwardDerivative = 0.35;
	public static double kStrafeProportional = 0.013;
 
	// Have some global constants that determine how the PIDs react on the gyro
	public static double kPGyro = 0.015;
	public static double kIGyro = 0.0;
	public static double kDGyro = 0.03;
	
	// Have some global constants that determine how the PIDs react on the wheel encoder
	public static double kPWheel = 0.035;
	public static double kIWheel = 0.005;
	public static double kDWheel = 0.5;
	//Good but slow values are kp = 0.035, ki 0.005, kd 0.75 and min speed 0.05.
	//Very accurate but slow - 3s for 50".  1s for small values.
	//May want a faster version for the initial long step in autonomous

	/**
	 * We want to limit how fast the mecanum starts up, so we only change by at most
	 * mecanumSensitivity each update. It's also a good place to put in a dead
	 * zone, currently 0.11 because the xbox stick often goes up to Â±0.1
	 */

	public void linearMecanum(double x, double y, double twist) {
		//Xbox joysticks are notoriously bad at keeping themselves calibrated to better than 0.1.  
		double deadzone = 0.11;
		if (Math.abs(x) < deadzone)
			currentX = 0;
		else {
			if (Math.abs(x - currentX) < mecanumSensitivity)
				currentX = x;
			else
				currentX = (x - currentX > 0) ? currentX + mecanumSensitivity : currentX - mecanumSensitivity;
		}

		if (Math.abs(y) < deadzone)
			currentY = 0;
		else {
			if (Math.abs(y - currentY) < mecanumSensitivity)
				currentY = y;
			else
				currentY = (y - currentY > 0) ? currentY + mecanumSensitivity : currentY - mecanumSensitivity;
		}

		if (Math.abs(twist) < deadzone)
			currentTwist = 0;
		else {
			if (Math.abs(twist - currentTwist) < mecanumSensitivity)
				currentTwist = twist;
			else
				currentTwist = (twist - currentTwist > 0) ? currentTwist + mecanumSensitivity
						: currentTwist - mecanumSensitivity;
		}

		RobotMap.drivetrainRobot.mecanumDrive_Cartesian(currentX, currentY, currentTwist, 0);
	}
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	@Override
	public void initDefaultCommand() {

		setDefaultCommand(new MecanumDrive());
	}
	public void reset(){
		RobotMap.wheelEncoder.reset();
		RobotMap.gyro.reset();
	}
	public boolean isGearPresent(){
		return (RobotMap.gearUltra.getVoltage() < 1.0) ? true : false ;
	}
}
